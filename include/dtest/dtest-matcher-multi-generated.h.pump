//==============================================================================
/**
 * @file    dtest/dtest-matcher-multi-generated.h
 *
 * @brief   header of Dtest multi-value matchers automatically generated
 *
 * @author  ymoch
 * @date    2014/11/01
 */
//==============================================================================
#ifndef INCLUDE_DTEST_DTEST_MATCHER_MULTI_GENERATED_H
#define INCLUDE_DTEST_DTEST_MATCHER_MULTI_GENERATED_H

#include "internal/dtest-combiners.h"

namespace dtest {

//==============================================================================
/**
 * @brief   variadic matcher (N = 1)
 */
//==============================================================================
template <class Combiner, class T1>
class VariadicMatcher1
{
public:
    /**
     * @brief       constructor
     */
    VariadicMatcher1(const T1& matcher)
        : matcher_(matcher) {}

    /**
     * @brief       check that it matches
     *
     * @tparam      ValueType       value type
     * @param[in]   value           value to Matches
     * @retval      true            it matches
     * @retval      false           it doesn't match
     */
    template <class ValueType>
    bool Matches(const ValueType& value) const
    {
        return matcher_.Matches(value);
    }

    /**
     * @brief       describe self
     *
     * @param       os      output stream to describe to
     */
    void DescribeTo(::std::ostream* os) const
    {
        *os << "(" << matcher_ << ")";
    }

private:
    T1 matcher_;    //!< matcher
};

$$ settings
$var variadic_min = 1
$var variadic_max = 10
$var variadic_class_min = 2

$range variadic_num variadic_min..variadic_max
$range variadic_class_num variadic_class_min..variadic_max

$$ variadic matcher
$for variadic_class_num [[

$range all 1..variadic_class_num
$range tail 2..variadic_class_num

//==============================================================================
/**
 * @brief   variadic matcher (N = $variadic_class_num)
 */
//==============================================================================
template <class Combiner, $for all, [[class T$all]]>
class VariadicMatcher$variadic_class_num
{
public:
    /**
     * @brief       constructor
     */
    VariadicMatcher$variadic_class_num($for all, [[const T$all& m$all]])
        : head_matcher_(m1), tail_matchers_($for tail, [[m$tail]]) {}

    /**
     * @brief       check that it matches
     *
     * @tparam      ValueType       value type
     * @param[in]   value           value to Matches
     * @retval      true            it matches
     * @retval      false           it doesn't match
     */
    template <class ValueType>
    bool Matches(const ValueType& value) const
    {
        return Combiner::Combine(
                    head_matcher_.Matches(value),
                    tail_matchers_.Matches(value));
    }

    /**
     * @brief       describe self
     *
     * @param       os      output stream to describe to
     */
    void DescribeTo(::std::ostream* os) const
    {
        *os << "(" << head_matcher_ << ") "
            << Combiner::GetOperatorString() << " "
            << tail_matchers_;
    }

private:
    /**
     * @brief       head matcher
     */
    T1 head_matcher_;

    /**
     * @brief       tail matchers
     */
    VariadicMatcher$(variadic_class_num - 1)<Combiner, $for tail, [[T$tail]]> tail_matchers_;
};

]] $$ variadic matcher

//==============================================================================
// definition of inline function
//==============================================================================
$$ output stream iterator
$for variadic_num [[

$range all 1..variadic_num

/**
 * @brief           operator << for VariadicMatcher$variadic_num
 *
 * @param[in,out]   os          output stream
 * @param[in]       matcher     matcher
 */
template <class Combiner, $for all, [[class T$all]]>
inline ::std::ostream& operator<<(::std::ostream& os, const VariadicMatcher$variadic_num<Combiner, $for all, [[T$all]]>& matcher)
{
    matcher.DescribeTo(&os);
    return os;
}

]] $$ output stream iterator

$$ and matcher
$for variadic_num [[

$range all 1..variadic_num

/**
 * @brief       create AND matcher
 *
 * @return      matcher
 */
template <$for all, [[class T$all]]>
inline VariadicMatcher$variadic_num<AndCombiner, $for all, [[T$all]]> AllOf($for all, [[const T$all& m$all]])
{
    return VariadicMatcher$variadic_num<AndCombiner, $for all, [[T$all]]>($for all, [[m$all]]);
}

]] $$ and matcher

$$ or matcher
$for variadic_num [[

$range all 1..variadic_num

/**
 * @brief       create OR matcher
 *
 * @return      matcher
 */
template <$for all, [[class T$all]]>
inline VariadicMatcher$variadic_num<OrCombiner, $for all, [[T$all]]> AnyOf($for all, [[const T$all& m$all]])
{
    return VariadicMatcher$variadic_num<OrCombiner, $for all, [[T$all]]>($for all, [[m$all]]);
}

]] $$ or matcher

} // namespace dtest

#endif // INCLUDE_DTEST_DTEST_MATCHER_MULTI_GENERATED_H
